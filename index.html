<!DOCTYPE html>
<html>

<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
</head>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://rawgit.com/jasondavies/d3-cloud/master/build/d3.layout.cloud.js"></script>

<body>
  <p id="status">Not Connected</p>
  <content>

  </content>
  <script>

    //Based on https://github.com/jasondavies/d3-cloud/blob/master/examples/simple.html
    // Encapsulate the word cloud functionality
    function wordCloud(selector) {

      var fill = d3.scale.category20();
      //Construct the word cloud's SVG element
      var svg = d3.select(selector).append("svg")
        .attr("width", 500)
        .attr("height", 500)
        .append("g")
        .attr("transform", "translate(250,250)");


      //Draw the word cloud
      function draw(words) {
        var cloud = svg.selectAll("g text")
          .data(words, function (d) { return d.text; })

        //Entering words
        cloud.enter()
          .append("text")
          .style("font-family", "Impact")
          .style("fill", function (d, i) { return fill(i); })
          .attr("text-anchor", "middle")
          .attr('font-size', 1)
          .text(function (d) { return d.text; });

        //Entering and existing words
        cloud
          .transition()
          .duration(600)
          .style("font-size", function (d) { return d.size + "px"; })
          .attr("transform", function (d) {
            return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
          })
          .style("fill-opacity", 1);

        //Exiting words
        cloud.exit()
          .transition()
          .duration(200)
          .style('fill-opacity', 1e-6)
          .attr('font-size', 1)
          .remove();
      }


      //Use the module pattern to encapsulate the visualisation code. We'll
      // expose only the parts that need to be public.
      return {

        //Recompute the word cloud for a new set of words. This method will
        // asycnhronously call draw when the layout has been computed.
        //The outside world will need to call this function, so make it part
        // of the wordCloud return value.
        update: function (words) {
          d3.layout.cloud().size([500, 500])
            .words(words)
            .padding(5)
            .rotate(function () { return ~~(Math.random() * 2) * 90; })
            .font("Impact")
            .fontSize(function (d) { return d.size; })
            .on("end", draw)
            .start();
        }
      }
    }

    function render_wordcloud() {
      document.getElementsByTagName("content")[0].innerHTML = ""
      const counts = {};
      for (const word of LARGE_TRANSCRIPT.split(' ')) {
        counts[word] = counts[word] ? counts[word] + 1 : 1;
      }
      var instructions = []
      for (const [key, value] of Object.entries(counts)) {
        instructions.push({ "text": key, "size": 30 + 20 * value })
      }
      wordCloud("content").update(instructions)
    }

    var STATE_NAME = "WORDCLOUD"
    var LARGE_TRANSCRIPT = ""

    function update_state(data) {
      if (data.channel.alternatives[0].transcript && data.is_final) {
        LARGE_TRANSCRIPT += ' ' + data.channel.alternatives[0].transcript
        console.log(LARGE_TRANSCRIPT)
        return true
      }
      return false
    }

    function render_state() {
      if (STATE_NAME == "WORDCLOUD") {
        render_wordcloud()
      }
    }

    navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
      console.log({ stream })
      if (!MediaRecorder.isTypeSupported('audio/webm'))
        return alert('Browser not supported')
      const mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'audio/webm',
      })
      const socket = new WebSocket('wss://api.deepgram.com/v1/listen', [
        'token',
        'cb8b6618675735c7896101b9377f325f1a5a9e80',
      ])
      socket.onopen = () => {
        document.querySelector('#status').textContent = 'Connected'
        console.log({ event: 'onopen' })
        mediaRecorder.addEventListener('dataavailable', async (event) => {
          if (event.data.size > 0 && socket.readyState == 1) {
            socket.send(event.data)
          }
        })
        mediaRecorder.start(1000)
      }

      socket.onmessage = (message) => {

        const received = JSON.parse(message.data)
        if (update_state(received)) {
          render_state()
        };
        const transcript = received.channel.alternatives[0].transcript
      }

      socket.onclose = () => {
        console.log({ event: 'onclose' })
      }

      socket.onerror = (error) => {
        console.log({ event: 'onerror', error })
      }
    })
  </script>
</body>

</html>